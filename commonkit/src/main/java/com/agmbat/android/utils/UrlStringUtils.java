package com.agmbat.android.utils;

import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.regex.Pattern;

import com.agmbat.security.SecurityUtil;

import android.net.Uri;
import android.util.Log;
import android.util.Patterns;
import android.webkit.URLUtil;

public class UrlStringUtils {

    private static final String TAG = "UrlStringUtils";

    private static final String THUMB_URL_TAG = "_is_thumbnail=true";

    /**
     * Regular expression pattern to match RFC 1738 URLs List accurate as of 2007/06/15. List taken from:
     * http://data.iana.org/TLD/tlds-alpha-by-domain.txt This pattern is auto-generated by
     * //device/tools/make-iana-tld-pattern.py
     */
    public static final Pattern WEB_URL_PATTERN = Pattern
            .compile("((?:(http|https|Http|Https|rtsp|Rtsp):\\/\\/(?:(?:[a-zA-Z0-9\\$\\-\\_\\.\\+\\!\\*\\'\\(\\)"
                    + "\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,64}(?:\\:(?:[a-zA-Z0-9\\$\\-\\_"
                    + "\\.\\+\\!\\*\\'\\(\\)\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,25})?\\@)?)?"
                    + "((?:(?:[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}\\.)+" // named host
                    + "(?:" // plus top level domain
                    + "(?:aero|arpa|asia|a[cdefgilmnoqrstuwxz])" + "|(?:biz|b[abdefghijmnorstvwyz])"
                    + "|(?:cat|com|coop|c[acdfghiklmnoruvxyz])" + "|d[ejkmoz]" + "|(?:edu|e[cegrstu])" + "|f[ijkmor]"
                    + "|(?:gov|g[abdefghilmnpqrstuwy])" + "|h[kmnrtu]" + "|(?:info|int|i[delmnoqrst])"
                    + "|(?:jobs|j[emop])" + "|k[eghimnrwyz]" + "|l[abcikrstuvy]"
                    + "|(?:mil|mobi|museum|m[acdeghklmnopqrstuvwxyz])" + "|(?:name|net|n[acefgilopruz])"
                    + "|(?:org|om)" + "|(?:pro|p[aefghklmnrstwy])" + "|qa" + "|r[eosuw]" + "|s[abcdeghijklmnortuvyz]"
                    + "|(?:tel|travel|t[cdfghjklmnoprtvwz])" + "|u[agkmsyz]" + "|v[aceginu]"
                    + "|w[fs]"
                    + "|y[etu]"
                    + "|z[amw]))"
                    + "|(?:(?:25[0-5]|2[0-4]" // or ip address
                    + "[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(?:25[0-5]|2[0-4][0-9]"
                    + "|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1]"
                    + "[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}" + "|[1-9][0-9]|[0-9])))"
                    + "(?:\\:\\d{1,5})?)" // plus option port number
                    + "(\\/(?:(?:[a-zA-Z0-9\\;\\/\\?\\:\\@\\&\\=\\#\\~" // plus option query params
                    + "\\-\\.\\+\\!\\*\\'\\(\\)\\,\\_])|(?:\\%[a-fA-F0-9]{2}))*)?" + "(?:\\b|$)"); // and finally, a
    // word boundary or
    // end of
    // input. This is to
    // stop foo.sure from
    // matching as foo.su

    public static final Pattern IP_PATTERN = Pattern.compile("(?:(?:25[0-5]|2[0-4]"
            + "[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(?:25[0-5]|2[0-4][0-9]"
            + "|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1]"
            + "[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}" + "|[1-9][0-9]|[0-9]))");

    public static boolean urlStartsWithIgnoreScheme(String url1, String url2) {
        URI uri1 = null;
        URI uri2 = null;
        try {
            uri1 = URI.create(url1);
            uri2 = URI.create(url2);
        } catch (IllegalArgumentException e) {
            Log.e(TAG, e.toString());
            return false;
        }
        if (uri1 == null || uri2 == null || uri1.getHost() == null || uri2.getHost() == null || uri1.getPath() == null
                || uri2.getPath() == null) {
            return false;
        }
        if ((uri1.getHost()).equalsIgnoreCase(uri2.getHost())) {
            if (uri1.getPath().toLowerCase().startsWith(uri2.getPath().toLowerCase())) {
                return true;
            }
        }
        return false;
    }

    public static String getUrlVerifiedStr(String str) {
        if (str == null) {
            return "";
        }
        if (WEB_URL_PATTERN.matcher(str).matches()) {
            return SecurityUtil.md5Hash(str);
        }
        try {
            URI uri = URI.create(str);
            if (uri == null || uri.getScheme() == null) {
                return str;
            }
        } catch (IllegalArgumentException e) {
            return str;
        }
        return SecurityUtil.md5Hash(str);
    }

    public static String getLikeUrlSelection(String urlColumn, String url) {
        String likeUrl = getLikeUrl(url);
        String selection = urlColumn + " = \"" + url + "\" or " + urlColumn + " = \"" + likeUrl + "\"";
        return selection;
    }

    public static String getLikeUrl(String url) {
        String likeUrl = null;
        if (url.endsWith("/")) {
            likeUrl = url.substring(0, url.length() - 1);
        } else {
            likeUrl = url + "/";
        }
        return likeUrl;
    }

    public static String optThumbUrl(final String url) {
        return url + THUMB_URL_TAG;
    }

    public static String optUrl(final String thumbUrl) {
        return thumbUrl.replace(THUMB_URL_TAG, "");
    }

    public static boolean isLocalThumbUrl(final String thumbUrl) {
        return thumbUrl.contains(THUMB_URL_TAG);
    }

    /**
     * Get query parameter from {@linkplain Uri} correctly.
     *
     * @param uri the {@linkplain Uri}
     * @param key the query key.
     * @return the decode query value of with key, or {@code null} if not found.
     */
    public static final String getQueryParameter(final Uri uri, final String key) {
        if (null == uri) {
            throw new IllegalArgumentException("uri");
        }
        if (uri.isOpaque()) {
            throw new UnsupportedOperationException("This isn't a hierarchical URI.");
        }
        if (key == null) {
            throw new IllegalArgumentException("key");
        }

        final String query = uri.getEncodedQuery();
        if (query == null) {
            return null;
        }

        final String encodedKey = Uri.encode(key, null);
        final int encodedKeyLength = encodedKey.length();

        int encodedKeySearchIndex = 0;
        final int encodedKeySearchEnd = query.length() - (encodedKeyLength + 1);

        while (encodedKeySearchIndex <= encodedKeySearchEnd) {
            final int keyIndex = query.indexOf(encodedKey, encodedKeySearchIndex);
            if (keyIndex == -1) {
                break;
            }
            final int equalsIndex = keyIndex + encodedKeyLength;
            if (equalsIndex >= query.length()) {
                break;
            }
            if (query.charAt(equalsIndex) != '=') {
                encodedKeySearchIndex = equalsIndex + 1;
                continue;
            }
            if (keyIndex == 0 || query.charAt(keyIndex - 1) == '&') {
                int end = query.indexOf('&', equalsIndex);
                if (end == -1) {
                    end = query.length();
                }
                try {
                    return URLDecoder.decode(query.substring(equalsIndex + 1, end), "UTF-8");
                } catch (final UnsupportedEncodingException e) {
                    // We never get here.
                    return null;
                }
            } else {
                encodedKeySearchIndex = equalsIndex + 1;
            }
        }
        return null;
    }

    /**
     * Searches the query string for parameter values with the given key.
     *
     * @param key which will be encoded
     * @return a list of decoded values
     * @throws UnsupportedOperationException if this isn't a hierarchical URI
     * @throws IllegalArgumentException      if key is null
     */
    public List<String> getQueryParameters(Uri uri, String key) {
        if (null == uri) {
            throw new IllegalArgumentException("uri");
        }
        if (uri.isOpaque()) {
            throw new UnsupportedOperationException("This isn't a hierarchical URI.");
        }

        String query = uri.getEncodedQuery();
        if (query == null) {
            return Collections.emptyList();
        }

        String encodedKey;
        try {
            encodedKey = URLEncoder.encode(key, "UTF-8");
        } catch (final UnsupportedEncodingException e) {
            throw new AssertionError(e);
        }

        // Prepend query with "&" making the first parameter the same as the
        // rest.
        query = "&" + query;

        // Parameter prefix.
        final String prefix = "&" + encodedKey + "=";

        final ArrayList<String> values = new ArrayList<String>();

        int start = 0;
        final int length = query.length();
        while (start < length) {
            start = query.indexOf(prefix, start);

            if (start == -1) {
                // No more values.
                break;
            }

            // Move start to start of value.
            start += prefix.length();

            // Find end of value.
            int end = query.indexOf('&', start);
            if (end == -1) {
                end = query.length();
            }

            final String value = query.substring(start, end);
            try {
                values.add(URLDecoder.decode(value, "UTF-8"));
            } catch (final UnsupportedEncodingException e) {
                throw new AssertionError(e);
            }

            start = end;
        }

        return Collections.unmodifiableList(values);
    }

    /**
     * 判断给定的字符患是不是url
     *
     * @param url
     */
    public static boolean isValidUrl(String url) {
        return (Patterns.WEB_URL.matcher(url).matches() && URLUtil.isValidUrl(url));
    }

}
