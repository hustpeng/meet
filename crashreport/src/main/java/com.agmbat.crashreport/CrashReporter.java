package com.agmbat.crashreport;

import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Environment;

import com.agmbat.android.utils.AppUtils;
import com.agmbat.android.utils.StorageUtils;
import com.agmbat.app.ActivityStack;
import com.agmbat.file.FileSizeFormat;
import com.agmbat.file.FileUtils;
import com.agmbat.io.IoUtils;
import com.agmbat.log.Log;
import com.agmbat.text.StringUtils;

import java.io.File;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.lang.Thread.UncaughtExceptionHandler;
import java.util.Date;
import java.util.Locale;
import java.util.Properties;

/**
 * <p>
 * Base class for any application which need to send crash reports. The final application has to extend this class and
 * at least implement the abstract method {@link #getReportEmail()} by returning a email that reports will be sent to.
 * </p>
 * Needs permission :android.permission.WRITE_EXTERNAL_STORAGE
 */
public class CrashReporter implements UncaughtExceptionHandler {

    private static final String CRASH_FILE = "crash.txt";

    private static final String VERSION_NAME_KEY = "VersionName";
    private static final String VERSION_CODE_KEY = "VersionCode";
    private static final String PACKAGE_NAME_KEY = "PackageName";
    private static final String PHONE_MODEL_KEY = "PhoneModel";
    private static final String ANDROID_VERSION_KEY = "AndroidVersion";
    private static final String SDK_VERSION_KEY = "SDKVersion";
    private static final String BOARD_KEY = "Board";
    private static final String BRAND_KEY = "Brand";
    private static final String DEVICE_KEY = "Device";
    private static final String DISPLAY_KEY = "Display";
    private static final String FINGERPRINT_KEY = "FingerPrint";
    private static final String HOST_KEY = "Host";
    private static final String ID_KEY = "Id";
    private static final String MODEL_KEY = "Model";
    private static final String PRODUCT_KEY = "Product";
    private static final String TAGS_KEY = "Tags";
    private static final String TIME_KEY = "Time";
    private static final String TYPE_KEY = "Type";
    private static final String USER_KEY = "User";
    private static final String TOTAL_MEM_SIZE_KEY = "TotalMem";
    private static final String AVAILABLE_MEM_SIZE_KEY = "AvailableMem";
    private static final String STACK_TRACE_KEY = "StackTrace";
    private static final String LOCAL_KEY = "Local";

    static final String EXTRA_REPORT_FILE_NAME = "REPORT_FILE_NAME";
    static final String EXTRA_REPORT_EMAIL = "REPORT_EMAIL";

    private static CrashReporter sInstance;

    private Context mContext;

    private String mStackString;

    // This is where we collect crash data
    private final Properties mCrashProperties = new Properties();

    /**
     * 使用weixin发送crash文件
     */
    private boolean mUseWinXinSendFile = true;

    public static void init(Context context) {
        if (sInstance == null) {
            sInstance = new CrashReporter(context);
        }
    }

    public static CrashReporter getInstance() {
        return sInstance;
    }

    private CrashReporter(Context context) {
        mContext = context;
        Thread.setDefaultUncaughtExceptionHandler(this);
    }

    @Override
    public void uncaughtException(Thread t, Throwable e) {
        // Generate and send crash report
        try {
            handleException(e);
        } catch (Throwable e2) {
            e2.printStackTrace();
        } finally {
            AppUtils.killMyProcess();
            System.exit(10);
        }
    }

    /**
     * Implement this method by returning a email that reports will be sent to.
     *
     * @return The Id of your GoogleDoc Form generated by importing ACRA's spreadsheet template.
     */
    public String getReportEmail() {
        return mContext.getString(R.string.crash_report_email);
    }

    /**
     * Override this method to change the location of crash report file. The file should be on external
     * storage,otherwise the email can't send this file as attachment.
     *
     * @return
     */
    public File getCrashReportFile() {
        return new File(Environment.getExternalStorageDirectory(), CRASH_FILE);
    }

    /**
     * Try to send a report, if an error occurs stores a report file for a later attempt.
     *
     * @param e The Throwable to be reported. If null the report will contain a new
     *          Exception("Report requested by developer").
     */
    private void handleException(Throwable e) {
        if (e == null) {
            e = new Exception("Report requested by developer");
        }
        ActivityStack.finishAll();
        retrieveCrashData();
        mStackString = getStackString(e);
        mCrashProperties.put(STACK_TRACE_KEY, "");
        saveCrashReportFile();
        showCrashDialog();
        Log.e(e);
    }

    /**
     * 是否使用微信发送文件
     *
     * @return
     */
    public boolean isUserWinXinSendFile() {
        return mUseWinXinSendFile;
    }

    public void setUseWinXinSendFile(boolean useWinXinSendFile) {
        mUseWinXinSendFile = useWinXinSendFile;
    }

    /**
     * 获取异常信息的堆栈跟踪信息。
     *
     * @param e 要解析的异常信息。
     * @return 该异常信息的堆栈跟踪信息。
     */
    private String getStackString(Throwable e) {
        // Build stack trace
        final Writer result = new StringWriter();
        final PrintWriter printWriter = new PrintWriter(result);
        e.printStackTrace(printWriter);
        // If the exception was thrown in a background thread inside
        // AsyncTask, then the actual exception can be found with getCause
        Throwable cause = e.getCause();
        while (cause != null) {
            cause.printStackTrace(printWriter);
            cause = cause.getCause();
        }
        final String causeString = result.toString();
        printWriter.close();
        return causeString;
    }

    /**
     * Collects crash data.
     */
    private void retrieveCrashData() {
        try {
            final PackageManager pm = mContext.getPackageManager();
            PackageInfo pi = pm.getPackageInfo(mContext.getPackageName(), 0);
            if (pi != null) {
                // Application Version
                mCrashProperties.put(VERSION_NAME_KEY, pi.versionName != null ? pi.versionName : "not set");
                mCrashProperties.put(VERSION_CODE_KEY, String.valueOf(pi.versionCode));
            } else {
                // Could not retrieve package info...
                mCrashProperties.put(PACKAGE_NAME_KEY, "Package info unavailable");
            }
            // Application Package name
            mCrashProperties.put(PACKAGE_NAME_KEY, mContext.getPackageName());
            // Device model
            mCrashProperties.put(PHONE_MODEL_KEY, Build.MODEL);
            // Android version
            mCrashProperties.put(ANDROID_VERSION_KEY, Build.VERSION.RELEASE);
            mCrashProperties.put(SDK_VERSION_KEY, String.valueOf(Build.VERSION.SDK_INT));

            // Android build data
            mCrashProperties.put(BOARD_KEY, Build.BOARD);
            mCrashProperties.put(BRAND_KEY, Build.BRAND);
            mCrashProperties.put(DEVICE_KEY, Build.DEVICE);
            mCrashProperties.put(DISPLAY_KEY, Build.DISPLAY);
            mCrashProperties.put(FINGERPRINT_KEY, Build.FINGERPRINT);
            mCrashProperties.put(HOST_KEY, Build.HOST);
            mCrashProperties.put(ID_KEY, Build.ID);
            mCrashProperties.put(MODEL_KEY, Build.MODEL);
            mCrashProperties.put(PRODUCT_KEY, Build.PRODUCT);
            mCrashProperties.put(TAGS_KEY, Build.TAGS);
            mCrashProperties.put(TIME_KEY, new Date(Build.TIME).toGMTString());
            mCrashProperties.put(TYPE_KEY, Build.TYPE);
            mCrashProperties.put(USER_KEY, Build.USER);
            mCrashProperties.put(LOCAL_KEY, Locale.getDefault().toString());

            // Device Memory
            mCrashProperties.put(TOTAL_MEM_SIZE_KEY,
                    FileSizeFormat.formatSize(StorageUtils.getTotalInternalMemorySize()));
            mCrashProperties.put(AVAILABLE_MEM_SIZE_KEY,
                    FileSizeFormat.formatSize(StorageUtils.getAvailableInternalMemorySize()));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 显示crash对话框
     */
    private void showCrashDialog() {
        // Always write the report file
        Intent intent = new Intent(mContext, CrashReportDialog.class);
        intent.putExtra(EXTRA_REPORT_FILE_NAME, getCrashReportFile().getPath());
        intent.putExtra(EXTRA_REPORT_EMAIL, getReportEmail());
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(intent);
    }

    /**
     * When a report can't be sent, it is saved here in a file in the root of the application private directory.
     */
    private void saveCrashReportFile() {
        final File file = getCrashReportFile();
        FileUtils.ensureParent(file);
        FileOutputStream fos = null;
        try {
            if (!file.exists()) {
                file.createNewFile();
            }
            fos = new FileOutputStream(file);
            mCrashProperties.store(fos, "");
            fos.write(StringUtils.getUtf8Bytes(mStackString));
            fos.flush();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            IoUtils.closeQuietly(fos);
        }
    }

}
